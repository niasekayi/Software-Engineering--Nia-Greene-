"""
Nia Greene
SID- @03067162

Boggle solver for assignment:
- Class name: Boggle
- Data members: Grid, Dictionary, solution
- Methods: setGrid, setDictionary, getSolution
- No imports; uses built-in types only
"""

class Boggle:
    """
    Boggle solver class.
    Grid: 2D list of tile-strings (like "A", "Qu", "St")
    Dictionary: set of lowercase words
    solution: final list of found words (lowercase)
    """

    def __init__(self, grid, dictionary):
        # Public data members (per spec)
        self.Grid = []          # will be NxN list of lowercase tile strings
        self.Dictionary = set() # set of lowercase words
        self.solution = []      # list (will be populated by getSolution)

        # Internal helpers
        self._N = 0
        self._prefixes = set()  # set of all prefixes from the dictionary

        # Initialize via setters (they also normalize case)
        self.setGrid(grid)
        self.setDictionary(dictionary)

    def setGrid(self, grid):
        """
        Set the NxN grid. Normalizes every tile to lowercase string.
        Empty grid [] or [[]] is valid.
        """
        if not grid or (len(grid) == 1 and len(grid[0]) == 0):
            # Handle [] or [[]] as empty grid
            self.Grid = []
            self._N = 0
            return

        N = len(grid)
        for row in grid:
            if len(row) != N:
                # Non-square is invalid
                raise ValueError("Grid must be NxN (square).")

        # Normalize to lowercase strings (keeps "Qu" -> "qu", "St" -> "st")
        self.Grid = [[str(cell).lower() for cell in row] for row in grid]
        self._N = N

    def setDictionary(self, dictionary):
        """
        Set the dictionary (list/iterable of words). Normalizes to lowercase set.
        Also precomputes prefix set for pruning.
        """
        if not dictionary:
            self.Dictionary = set()
            self._prefixes = set()
            return

        self.Dictionary = set(str(word).lower() for word in dictionary)
        # Build prefixes including full words so DFS can prune quickly
        prefixes = set()
        for w in self.Dictionary:
            # add every prefix from length 1 to len(w)
            for i in range(1, len(w) + 1):
                prefixes.add(w[:i])
        self._prefixes = prefixes

    def getSolution(self):
        """
        Returns a sorted list of found words (lowercase).
        Words must be at least 3 letters long (counts letters, so 'qu' counts as 2).
        """
        # Reset solution storage
        found = set()
        if not self.Grid or not self.Dictionary or self._N == 0:
            self.solution = []
            return self.solution

        # DFS from each cell
        for y in range(self._N):
            for x in range(self._N):
                visited = [[False] * self._N for _ in range(self._N)]
                self._dfs(y, x, "", visited, found)

        # Only accept words that are in the dictionary and length >= 3
        result = sorted(w for w in found if w in self.Dictionary and len(w) >= 3)
        self.solution = result
        return self.solution

    # Allow grader calls like mygame.solution()
    def solution(self):
        return self.getSolution()

    # Internal DFS
    def _dfs(self, y, x, cur_word, visited, found_set):
        # boundary / revisit check
        if y < 0 or x < 0 or y >= self._N or x >= self._N or visited[y][x]:
            return

        tile = self.Grid[y][x]           # tile string, e.g. "a", "qu", "st"
        new_word = cur_word + tile

        # Prefix pruning: if no dictionary word starts with new_word, stop
        if new_word not in self._prefixes:
            return

        # If it's a valid dictionary word of length >= 3, add it
        if len(new_word) >= 3 and new_word in self.Dictionary:
            found_set.add(new_word)

        # Continue DFS to neighbors
        visited[y][x] = True
        for dy in (-1, 0, 1):
            for dx in (-1, 0, 1):
                if dy == 0 and dx == 0:
                    continue
                self._dfs(y + dy, x + dx, new_word, visited, found_set)
        visited[y][x] = False


def main():
    # Example grid (matches prompt). Tiles can be "Qu" and "St".
    grid = [
        ["T", "W", "Y", "R"],
        ["E", "N", "P", "H"],
        ["G", "St", "Qu", "R"],
        ["O", "N", "T", "A"]
    ]

    dictionary = [
        "art", "ego", "gent", "get", "net", "new", "newt", "prat", "pry",
        "qua", "quart", "quartz", "rat", "tar", "tarp", "ten", "went", "wet",
        "arty", "rhr", "not", "quar"
    ]

    # Create game and get solution
    mygame = Boggle(grid, dictionary)
    found = mygame.getSolution()
    print("Found words:", found)


if __name__ == "__main__":
    main()
